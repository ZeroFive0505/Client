#include <iostream>

// Ctrl + Shift + B를 이용해서 전체 솔루션을 빌드(컴파일)한다.
// Ctrl + B를 누르면 현재 프로젝트를 빌드.

int main()
{

	std::cout << "Output\n";

	// 변수를 선언과 동시에 초기화할 수 있다.
	int number = 0;

	// 변수를 선언하고 값을 대입하지 않음. 쓰레기 값이 들어있다.
	int number1;

	// cin은 값을 입력받을때 사용한다.
	std::cin >> number1;

	std::cout << number1 << "\n";

	// 상수: 값을 바꿀 수 없는 메모리이다.
	// 변수 타입 앞에 const를 붙여서 상수로 만들어 줄 수 있다.
	// 상수는 값을 바꿀 수 없기 때문에 반드시 선언과 동시에
	// 원하는 값으로 초기화 해놓고 사용해야 한다.
	// 중간에 절대로 값을 바꿔서는 안된다.
	const int numberConst = 1;

	/*
	* 대입연산자: = 를 말한다.
	* 대입연산자는 오른쪽의 값을 왼쪽으로 대입해준다.
	* 
	* 사칙연산자: +, -, *, /, % (나머지 연산자)
	* +, -, *, / 는 수학의 사칙연산자와 동일하다.
	* +, - 보다 *, / 가 우선순위가 높아서 먼저 연산이 된다.
	* % 연산자는 10 % 3 == 1
	* 10 / 3 == 3 - 1 결과는 1이된다.
	* 연산시 우선순위를 위해 괄호를 지원한다.
	* (), {}, [] X
	* 프로그래밍에서는 () 만을 이용해서 처리한다.
	*/

	number = 10 % 3;

	std::cout << number << "\n";


	/*
	* 관계연산자 : <, >, <=, >=, ==(같다), !=(다르다)
	* 프로그래밍에서 보통 !는 부정의 의미로 활용이 된다.
	* 
	* 관계연산자는 값 대 값을 연산하여 결과로 참/거짓이 나오게 된다.
	* 
	* 첨 거짓은 0은, 참은 0이 아닌 모든 수는 참으로 인식된다.
	* 하지만 true는 C++에서는 기본으로 1로 설정이 되어있다.
	*/

	std::cout << true << std::endl;


	bool test = 10 < 20;
	std::cout << "10 < 20 : " << test << "\n";
	test = 10 > 20;
	std::cout << "10 > 20 : " << test << "\n";
	test = 10 <= 20;
	std::cout << "10 <= 20 : " << test << "\n";
	test = 10 >= 20;
	std::cout << "10 >= 20 : " << test << "\n";
	test = 10 != 20;
	std::cout << "10 != 20 : " << test << "\n";

	/*
	* 논리 연산자 : AND(&&), OR(||)(Shift + \), NOT(!)
	* 참/거짓 대 참/거짓을 연산하여 결과로 참/거짓이 나오게된다.
	* A   B     AND      OR
	* F   F      F       F
	* T   F      F       T
	* F   T      F       T
	* T   T      T       T
	* 
	* AND는 둘다 참일 경우에만 참이고 아니면 거짓.
	* OR는 둘중 하나라도 참일 경우에는 참이고 아니면 거짓이다.
	* 
	* A   NOT
	* F    T
	* T    F
	* 
	* NOT은 반대로 결과가 나오게됨.
	*/


	std::cout << "false && false = " << (false && false) << "\n";
	std::cout << "true && false = " << (true && false) << "\n";
	std::cout << "false && true = " << (false && true) << "\n";
	std::cout << "true && true = " << (true && true) << "\n";

	std::cout << "false || false = " << (false || false) << "\n";
	std::cout << "true || false = " << (true || false) << "\n";
	std::cout << "false || true = " << (false || true) << "\n";
	std::cout << "true || true = " << (true || true) << "\n";

	std::cout << "!true = " << !true << "\n";
	std::cout << "!false = " << !false << "\n";

	/*
	* 진수 변환
	* 2진수 8진수 10진수 16진수
	* 2진수: 0, 1 2가지 숫자로 구성된 숫자이다.
	* 10진수: 0 ~ 9 사이의 숫자로 구성된 숫자이다.
	* 16진수: 0 ~ 15 사이로 구성된 숫자이다.
	* 10 ~ 15는 A ~ F로 표현한다.
	* 
	* 2진수 표현시에는 앞에 0b 붙여주고 16진수 표현시에는 0x를 붙여준다.
	* 0b00000001
	* 0xffffa200
	* 
	* 10진수 91일 2진수, 16진수로 변환해본다.
	* 
	* 91 / 2 = 45 -- 1
	* 45 / 2 == 22 -- 1
	* 22 / 2 == 11 -- 0
	* 11 / 2 == 5 -- 1
	* 5 / 2 == 2 -- 1
	* 2 / 2 == 1 -- 0
	* 0b1011011
	* 
	* 1011011을 10진수로 변환
	* 1	 0  1  1 0 1 1
	* 64 32 16 8 4 2 1
	* 64 + 16 + 8 + 2 + 1 = 91
	* 
	* 1011011을 16진수로 변환한다.
	* 16진수 1자리는 2진수 4자리를 차지한다.
	* 0101 / 1011
	* 8421   8421
	* 
	* 5 / 11 == 0x5b
	* 
	* 0x5b를 2진수 변환한다.
	* 16진수 각 자리를 2로 나누어서 구해준다.
	* 
	* 11 / 2 = 5 -- 1
	* 5 / 2 = 2 -- 1
	* 2 / 2 = 1 --0
	* 1011
	* 
	* 5 / 2 = 2 -- 1
	* 2 / 2 = 1 -- 0
	* 101
	* 
	* 1011011
	*/

	std::cout << 0b011101 << "\n";
	std::cout << 0xfffa200 << "\n";

	/*
	* 비트단위 논리 연산자 : AND(&), OR(|), NOT(~), XOR(^)
	* 값 대 값을 연산하여 결과로 값이 나오게 된다.
	* 먼저 연산하는 값들을 2진수로 변환한 후에 2진수 각 자리별로 논리연산을 수행해준다.
	* 비트단위 연산이기에 아주 빠르게 연산을 할 수 있다. (컴퓨터는 2진수로 데이터를 처리하기에)
	* 
	*  A   B    XOR
	*  F   F     F
	*  F   T     T
	*  T   F     T
	*  T   T     F
	* 
	* XOR는 둘이 같을때는 거짓이 나오게되고 다를때 참이 나온다.
	* 
	* 91 & 107
	* 91  : 1011011
	* 107 : 1101011
	* 
	*  1011011
	* &1101011
	*  1001011
	* 
	*  1011011
	* |1101011
	*  1111011
	* 
	*  1011011
	* ^1101011
	*  0110000
	*/

	std::cout << "91 & 107 = " << (91 & 107) << "\n";
	std::cout << "91 | 107 = " << (91 | 107) << "\n";
	std::cout << "91 ^ 107 = " << (91 ^ 107) << "\n";

	unsigned char numberU = 10;

	// 00001010
	// 가장 왼쪽 1비트는 부호비트로 0이면 +, 1이면 -
	// ~ 을 연산하면 각 비트들을 모두 반대로 바꿔주게 된다.
	// 11110101
	std::cout << "~10 = " << ~numberU << "\n"; 
	// -11이 나오는 이유는 부호비트를 제외한 나머지 값을 10진수로 바꿔주면 117이 나오게 되는데
	//  이를 128에서 빼주어서 128 - 117 = 11이 나오게 되는데 이를 128에서 빼주어서 128 - 117 = 11 이 나오고 여기에 -가 붙게된다.
	// 	또는
	// -128에서 117을 더하게 되면 -11이 나오게 된다.
	std::cout << 0b11110101 << "\n";

	// int 4바이트이다. 32bit
	int Buf = 0;
	const int Attack = 0x1; // 1
	const int Armor = 0x2; // 10
	const int HP = 0x4; // 100
	const int MP = 0x8; // 1000
	const int Critical = 0x10; // 10000

	// Buf = 0 | 1 = 1
	Buf = Buf | Attack;

	// Buf = 1 | 1000 = 0b1001 = 9
	Buf = Buf | MP;

	// Buf = 01001 | 10000 = 0b11001 = 25
	Buf = Buf | Critical;

	// Buf = 11001 ^ 01000 = 10001
	Buf = Buf ^ MP;

	// Buf = 10001 ^ 01000 = 11001
	Buf = Buf ^ MP;

	std::cout << Buf << "\n";

	// 11001 & 00001 = 1
	std::cout << "Attack = " << (Buf & Attack) << "\n";
	// 11001 & 00010 = 0
	std::cout << "Armor = " << (Buf & Armor) << "\n";
	// 11001 & 00100 = 0
	std::cout << "HP = " << (Buf & HP) << "\n";
	// 11001 & 11001 = 1000
	std::cout << "MP = " << (Buf & MP) << "\n";
	// 11001 & 11001 = 10000
	std::cout << "Critical = " << (Buf & Critical) << "\n";

	/*
	* 쉬프트 연산자 : <<, >> 2가지가 있다.
	* 값 대 값을 연산하여 값으로 나오게 된다.
	* 2진수 단위의 연산을 처리한다.
	* 10 = 1010이 나온다.
	* 
	* 이경우 왼쪽으로 2칸 이동하라는 의미이다.
	* 오른쪽에 0을 2개 붙이면된다.
	* 101000
	* 10 << 2 == 101000이 된다. 40이 된다.
	* 10 << 3 == 1010000이 된다. 80이 된다.
	* 
	* 10 << 2는 10을 2^2 곱한것과 같다.
	* 10 << 3는 10을 2^3 곱한것과 같다.
	* 10 << 4는 10을 2^4 곱한것과 같다.
	* 
	* 그래서 빠른 곱하기 연산이라고도 한다.
	* 
	* 오른쪽 연산하면 오른쪽 2자리를 제거
	* 10 >> 2 = 10이 된다. 2이다.
	* 10 >> 3 = 1이 된다. 1이다.
	* 
	* 10 / 2^2 = 2
	* 10 / 2^3 = 1
	* 
	* 빠른 나눗셈이라고도 한다.
	*/

	std::cout << "10 << 2 = " << (10 << 2) << "\n";
	std::cout << "10 << 3 = " << (10 << 3) << "\n";
	std::cout << "10 >> 2 = " << (10 >> 2) << "\n";
	std::cout << "10 >> 3 = " << (10 >> 3) << "\n";

	return 0;
}